## なにこれ
[GCPUG Tokyo gVisor Day July 2018 - connpass](https://gcpug-tokyo.connpass.com/event/90909/)にきたよ。有名な@Harukaiwaoさんが新しい仮想化であるgVisorについて語る。[ぎっはぶはここ](https://github.com/google/gvisor)。[GCPUGはここ](https://gcpug.jp/)

このノートはComのKnowledge Sharing MeetingやTech Lunchで話すとき用に書いてる備忘録

## まとめ
Q. gVisorは何をもたらした？
A. 従来から抱えていたコンテナの問題を解決した。ただし遅くなった。

Q. へー。どうやって試すの？
A. ほげ

Q. sandboxってなに？

## オープニング

コンテナの歴史を振り返りつつなぜgVisorが必要なのか。2013年にdockerがリリースされてから、コンテナ技術が一気に広まった。Googleは10年以上にわたって自社サービスの管理にコンテナを利用しており、現在は毎週40億以上のコンテナを起動している。
なぜgoogleはコンテナを選んでいるのか？
性能、分離、再現性がコンテナを選ぶ理由。まあみんなそうだよねという感じ。

ただしコンテナには問題が在る。**But containers do not contain**というセキュリティ上の懸念がのこる。コンテナなのに閉じていない。
様々な分離のためのメカニズムが搭載されているコンテナだけど、このセキュリティ上のも懸念は残っているのだ。

### 原初の時代:rootユーザによるサービス運営

サービスはかつてrootで実行されていた。当然、全てのファイル・リソース・デバイスにアクセス可能。やばすぎる〜〜
もし、なにか１つでもおかしなことがあったら…ソフトウェアのバグ、悪意のある活動、脆弱性…。rootでやってるんだからまーとうぜん。

### 次の時代:rootはやばい！非特権ユーザーでの実行。
非特権ユーザーで実行する流れになる。実行前に権限が確認され、デバイスやファイルへのアクセスを制限することができる。
しかし、制限ユーザーが特権行為を`[setuid](https://ja.wikipedia.org/wiki/Setuid)`や`[raw socket](https://ja.wikipedia.org/wiki/Raw_socket)`を使うことができたら…？
raw socketはありとあらゆるパケットをなげつけられる。いろいろと偽装できちゃう。こまる。デバイスやファイルへのアクセスを制御するだけでは不十分なのだ。

>setuid
>一般ユーザーが高い特権レベルでしか実行できないタスクを一時的に実行できるようにする仕組みである。
>[setuid - Wikipedia](https://ja.wikipedia.org/wiki/Setuid)

>raw socket
>標準のソケットでは、送信するペイロードは選択したトランスポート層のプロトコル（例: TCP、UDP）によってカプセル化される。 対照的にraw socketは通常ヘッダを含んだ生のパケットを受信する。パケットを送るとき、ヘッダの自動的な追加はソケットの変更可能なオプションとなるだろう。
>[Raw socket - Wikipedia](https://ja.wikipedia.org/wiki/Raw_socket)


### 次の時代:デバイス・ファイルアクセスの制限だけでは不十分！Linux Capabilitiesの制限

LinuxのCapabilitiesという能力を制限するという流れになった。

#### Capabilitiesとは？
capability:
  1. 能力・才能・手腕・**力量**.
  2. (国家の)戦闘能力
  3. 素質・潜在能力・可能性


例えば、DockerはコンテナのCapabilitiesを制限している。
Sy_admin,sys_nice,net_admin,sysrawio,sys_module,etc…
けーぱびりてぃを減らすということが良い分離である。
しかし、リソースの分離という問題が残っている。
そこで出てきたのyが、cgroupsというしくみ。
リソースグループの制限、計測、分離を行う。cpu,cpuset devices, memory.



### 次の時代:デバイス・ファイルアクセスの制限だけでは不十分！Linux Capabilitiesの制限
ここまで制限しても、これでもプロセスはシステム上のすべてのユーザー、プロセスネットワーク・インターフェース、マウントポイント、、ぜんぶみれちゃう。psできるでしょ？lsできるでしょ？
つーことで、namespacesを用意する。現在、7つの名前空間がサポートされている。network,PID,mount,user,IPCUTS,cgroup
リソース名を割り当てる再の柔軟性も付与される。
（すらっしゅあっぷってなんだ？）
さあ、これらの仕組みでプロセスは十分に分離…されたのだろうか…・
否！！
Still containsers don’t contain
問題１：単一の脆弱性が特権昇格や情報の漏洩をゆる可能性がある。DirtyCow, Spectre/Meltdown…・ほったさんおつかれさまです (edited)
問題２：ネットワークスタックは複数コンテナで共有されたままである。CVE-20134348　不正なパケットを
で、なぜこういったもんだが起きるのか？
軽量な理由はホストカーネルがひとつしかないから。表裏一体。 (edited)
コンテナを安全にするためには、コンテナ内のプログラムからホストに影響が及ぼせないこと。普通のコンテナと同じぐらい簡単につかえること。アプリーけションの変更が不要であること。ほとんど設定不要で使えること。コンテナのメリットはそのまま残ること。柔軟性と少ないsリソースをのこしたまま・・・
で、できたのがgVisor
よく見る図が出てくる。仮想レイヤのはなし
仮想マシンはハードウェアをエミュレートして、完全なOSを実行する。すぐれた分離セイ、互換性を持つ。しかし、高いオーバーヘッド、メモリ使用量。固定されたcpu/memory割当
もう一つは、ルールに基づいたアクセス制御。seccomp,Selinux,apparmorなどなど。非常に良い性能・ネイティブ環境に匹敵する。しかし、ルールの定義が大変で、道のバイナリに対応しづらい。柔軟性にかける。 (edited)
このふたつのアイデアのいいとこ取りをしよう。grpcと良い最近こういうのおおいな・・。
いい点は、独立したカーネルであること。ハードウェアの仮想化であること。明確な権限の分離とカプセル化。
避けた移転は、仮想化されたHDI仮想化は（つぎのすらいどいっちゃった９
Linuxカーネルはとても大きい。x86_64のlinuxには319のシステムコールが存在する。
1999年以降で200子くらいのcveがあり、そのうちの１割強が特権昇格ができちゃう。やばい。
linuxは規模からいっても、そんなに「安全」なソフトウェアではない。
そういうカーネル。
歴史を振り返ると、よく使われている技術がサンドボックス可というものがある。
gVisorの概要。
この概念をコンテナにも導入できないか？といのがGviwor
ユーザーモードで動作する小さなカーネル。
カーネル内でシステムコールをトラップし実行する。
通常のプロセスのような柔軟なスレッド、メモリ割り当て
「仮想化と比べて」低いオーバーヘッド
干すカーネルから見れば、gvisoはたんなるps
通常のプロセスとおんなじ、柔軟性をそこなわない
gVisorについて。さらに。
信頼されないアプリケーションをサンドボックス可。Linuxのシステムコルをスクラッチで実装。やばそう
現在２１１のシステムコールを実装している
単なるフィルタリングではない
ユーザーもd−linuxのような移植版ではない
辺くを加えないlinuxバイナリを実行可能(NalCLとの違い）
また、最初からセキュアである。AppArmorやSELIぬんおポリシーと言ったフィルタが設定不要。さん土木巣ごとに１つのユーザーモードカーネルを実行できる。
メモリ及び方安全のために:gopher: で記述されている。
gVisorのアーキテクチャについて
Sentryというプロセスと、Goferというプロセスが動いている。
Sentryはシステムコールをエミュレートする。Goferはファイルアクセスを専任に受け持つ。
IPC’(9P)で通信する。
ネットワ０苦はSentryないのユーザーモード、ネットワークスタックで処理
Gofer- ファイルアクセスのための専用プロセス。
なぜ分けるか？ふたつのpsに
最も頻繁にeploitされる質てもコールがsocket(2)とopen(2)
Sentryはこれらの呼び出しを許可されない。Sentryがもし乗っ取られた都市hてもファイルにアクセスしたりポートをひらくこｔができない。
システムコールをトラップするのはptrace。PTRACE＿SYSEM雨を使ってシステムコールをトラップする。すべてのLinux環境で動作するというメリットがある。互換性がたかい。
もうひとつはKVM(試験的）ｇVisorがVMM券げすとOSとして動作する。ハードウェアによる仮想化サポートが要件。
gVisorの性能について。メモリ使用量は15MB,起動時間は150ms。システムコールに若干のオーバヘッドというレベル。
コンテナはもっともとはやい、15msというはやさ。ただし仮想マシンよりもはやい。
gVisorが向いていない場面
異なる種類のゲストOSを動作させること。(linux上でうぃんどｗｓなど）
完全に信頼されたバイナリを実行する場合。
最適な性能を得るためには通常のコンテナを使う。
システムコールを多様するアプリケーションもむいてない
完全なアプリケーションｗの互換性を期待するのもターゲット外
Sentryは多くのシステムコールをサポートするが、全てではない。
それってLinuxの再実装じゃん？みたいなはなし
テスト済みアプリはいっぱい。go,nod,httpd,php,prometheus,java8,jenkins,python,mariadb,redis,registrymemcached,mongotomcat,wordpress,
かなりカバーしてるね。
gVisGAEはgVisorで動作している。短い起動速度と低いおバーヘッドが不可欠だから。
もうひとつ、OSカーネル自体の研究開発につかえるのではないかと期待されている。
gVisorをosカーネルの研究開発に利用できることがしてkしあれている。gvisorにごｄエヘンクオを加え、ユーザーモードで試験をする。Cでやるよりずっとはやーい！
理解した上で選択するのがもっともだいじ。gVisorは安全なサンドボックス内でコンテナを実行する新しい手法。裏方で動いている技術を理解することは、じぶんおアプリケーションのために最適なプラットフォームを選ぶ上で大事
gVisorを実行する方法はかんたん。dockerでやるときに--runtime=runscやるだけ
くばねのときは、crio.confに１行たすだけでいい。
単一コンテナのpodがサポート、複数こんてなのpodはちょい待って（実装中 (edited)
デモ。dockerで--runtime=runscをつけた場合、つけてない場合のやつ。runscつけるとgvisor上の実行になるため、メルトダウンがきかない。なしだとメルトダウン有効。あちゃー。
dockerで/proc/cpuinfo|lessはしらせてみ。そんだけでわかるから。
まとめ
サンドボクス内で安全にコンテナを実行する新しい手法
みじかいきどうじかん、柔軟なスレッドとメモリ割り当て、最小限のオーバーヘッド
メモリと方安全性のためにGoで記述されている
コンテナとホストOSの間に厳格な境界をもたらす (edited)
信頼されていないバイナリをコンテナ内でより安全に実行できる
裏方の技術をしることは正しい判断をする上で大切

say3no [8:18 PM]
休憩をはさんで次のプレゼンターは@apstndbさん (edited)
TITLE:gVisorとGCP

say3no [8:30 PM]
https://blog.jessfraz.com/post/containers-security-and-echo-chambers/
Jessie Frazelle's Blog
Jessie Frazelle's Blog: Containers, Security, and Echo Chambers
A rant on containers, security, and echo chambers.
gVisorがトレードオフとしたリソース効率の重要度はどれだけ高いのか？
googleは100%再生可能可能エネルギーで動かしてる。普通の企業だとなかなかできない。効率が悪いとユーザへのコストに添加されてしまう。電源設計レベルでも効率を追求。新規開発してでもサンドボックスもだきょうしないのは納得
36k google app engine RCE
se-2014-02 GAE java security sandbox bypasses
https://gist.github.com/apstndb
