## なにこれ
aiueiuaiueoiueoiueoiuoeui
あいうえおあいうえおあいうえお
[GCPUG Tokyo gVisor Day July 2018 - connpass](https://gcpug-tokyo.connpass.com/event/90909/)にきたよ。その内容をまとめたもの。

 - [ぎっはぶはここ](https://github.com/google/gvisor)
 - [GCPUGはここ](https://gcpug.jp/)

## オープニング

コンテナの歴史を振り返りつつなぜgVisorが必要なのか。2013年にdockerがリリースされてから、コンテナ技術が一気に広まった。Googleは10年以上にわたって自社サービスの管理にコンテナを利用しており、現在は毎週40億以上のコンテナを起動している。
なぜgoogleはコンテナを選んでいるのか？
性能、分離、再現性がコンテナを選ぶ理由。まあみんなそうだよねという感じ。

ただしコンテナには問題が在る。**But containers do not contain**というセキュリティ上の懸念がのこる。コンテナなのに閉じていない。
様々な分離のためのメカニズムが搭載されているコンテナだけど、このセキュリティ上のも懸念は残っているのだ。

## セキュアなプロセスの歴史~分離のためのメカニズム〜
### 1. rootユーザによるサービス運営

サービスはかつてrootで実行されていた。当然、全てのファイル・リソース・デバイスにアクセス可能。やばすぎる〜〜
もし、なにか１つでもおかしなことがあったら…ソフトウェアのバグ、悪意のある活動、脆弱性…。rootでやってるんだからまーとうぜん。

### 2. rootはやばい！非特権ユーザー(一般ユーザー)での実行。
非特権ユーザーで実行する流れになる。実行前に権限が確認され、**デバイスやファイルへのアクセスを制限することができる。**
しかし、制限ユーザーが[setuid](https://ja.wikipedia.org/wiki/Setuid)や[raw socket](https://ja.wikipedia.org/wiki/Raw_socket)を使うことができたら…？
raw socketはありとあらゆるパケットをなげつけられる。いろいろと偽装できちゃう。こまる。デバイスやファイルへのアクセスを制御するだけでは不十分なのだ。

> * [setuid - Wikipedia](https://ja.wikipedia.org/wiki/Setuid)
>
>一般ユーザーが高い特権レベルでしか実行できないタスクを一時的に実行できるようにする仕組みである。
>

> * [Raw socket - Wikipedia](https://ja.wikipedia.org/wiki/Raw_socket)
>
>標準のソケットでは、送信するペイロードは選択したトランスポート層のプロトコル（例: TCP、UDP）によってカプセル化される。 対照的にraw socketは通常ヘッダを含んだ生のパケットを受信する。パケットを送るとき、ヘッダの自動的な追加はソケットの変更可能なオプションとなるだろう。
>

### 3. デバイス・ファイルアクセスの制限だけでは不十分！Linux Capabilitiesの制限

かつて、rootと一般ユーザの違いはファイルアクセスだけだった。それでは困るので、一般ユーザとrootの違いを、アクセサビリティだけでなく、capabilities(能力・権限）の有無でも管理しよう！ということになった。(Kernel 2.4から登場)

 - [ケーパビリティで権限を少しだけ与える - いますぐ実践! Linuxシステム管理 / Vol.183](http://www.usupi.org/sysad/183.html)
   - >Linuxにはrootが持っている絶対的な権限を小分けにし細かくした権限を**プロセス**に与えられるようにする機構があります。
 - [capabilities(7) - Linux manual page](http://man7.org/linux/man-pages/man7/capabilities.7.html)
 - [Man page of CAPABILITIES](https://linuxjm.osdn.jp/html/LDP_man-pages/man7/capabilities.7.html#index)
    - `man capabilities`を和訳したやつ
 - [権限を最小化するLinuxカーネルケーパビリティ － ＠IT](http://www.atmarkit.co.jp/fsecurity/rensai/lids03/lids01.html)

これによって、一般ユーザがどうしてもroot権限が必要な場合は、事前にroot能力の一部をcapabilitiesによって移譲しておけばよい。ことになったし

#### capabilitiesの確認
各プロセスにcapabilitiesが設定されていることを確認できる。
```
root@5b275a140953:/proc# grep Cap /proc/1/status 
CapInh:	00000000a80425fb
CapPrm:	00000000a80425fb
CapEff:	00000000a80425fb
CapBnd:	00000000a80425fb
CapAmb:	0000000000000000
```

Inh,Prm,Eff,Bnd,Ambってなに？

#### Dockerはcapabilitiesを制限している
例えば、DockerはコンテナのCapabilitiesを制限している。
Sy_admin,sys_nice,net_admin,sysrawio,sys_module,etc…
プロセスに与えるcapabilitiesが少ないということが良い分離であり、セキュアであるということ。
しかし、memory,cpu,IOなどのリソースの分離という問題が残っている。

### 4. cgropusによるリソースグループの分離・管理
Kernel 2.6.24でマージされたcgroups(control groups)は、リソースグループの制限、計測、分離を行う。cpu,cpuset devices, memory.

### 5. namespacesの登場
ここまで制限しても、これでもプロセスはシステム上のすべてのユーザー、プロセスネットワーク・インターフェース、マウントポイント、ぜんぶみれちゃう。
psできるでしょ？lsできるでしょ？
つーことで、namespacesを用意する。現在、7つの名前空間がサポートされている。network,PID,mount,user,IPCUTS,cgroup
リソース名を割り当てる再の柔軟性も付与される。
（すらっしゅあっぷってなんだ？）

## Still containsers don’t contain
Linuxの歴史は、これだけのプロセスをセキュアにするためのメカニズムを生み出してきた。これだけの仕組みは、はたしてコンテナを十分セキュアで、適切に分離された形での運用を可能とするのだろうか。

**否！！**

 - 問題１：単一の脆弱性が特権昇格や情報の漏洩をゆる可能性がある。DirtyCow, Spectre/Meltdown…
 - 問題２：ネットワークスタックは複数コンテナで共有されたままである。CVE-20134348　不正なパケットを
    - ちなみに、[CVE](http://cve.mitre.org)はCommon Vulnerabilities and Exposures(共通脆弱性識別子)のイニシャル。ソフトウェアの脆弱性を対象として、米国政府の支援を受けた非営利団体のMITRE社が提供している脆弱性情報データベースのこと。

で、なぜこういったもんだが起きるのか？
軽量な理由は**ホストカーネルがひとつしかないから。**脆弱性と表裏一体。 

 - コンテナを安全にするためには、コンテナ内のプログラムからホストに影響が及ぼせないこと。
 - 普通のコンテナと同じぐらい簡単につかえること。
 - アプリケーションの変更が不要であること。ほとんど設定不要で使えること。
 - コンテナのメリットはそのまま残ること。
  - 柔軟性と少ないリソースをのこしたまま・・・

## 仮想化のはなし
で、できたのがgVisor
よく見る図が出てくる。仮想レイヤのはなし
仮想マシンはハードウェアをエミュレートして、完全なOSを実行する。すぐれた分離、互換性を持つ。しかし、高いオーバーヘッド、メモリ使用量。固定されたcpu/memory割当
もう一つは、ルールに基づいたアクセス制御。seccomp,Selinux,apparmorなどなど。非常に良い性能・ネイティブ環境に匹敵する。しかし、ルールの定義が大変で、道のバイナリに対応しづらい。柔軟性にかける。 
このふたつのアイデアのいいとこ取りをしよう。grpcと良い最近こういうのおおいな・・。
いい点は、独立したカーネルであること。ハードウェアの仮想化であること。明確な権限の分離とカプセル化。
避けた移転は、仮想化されたHDI仮想化は（つぎのすらいどいっちゃった９

Linuxカーネルはとても大きい。x86_64のlinuxには319のシステムコールが存在する。
1999年以降で200子くらいのcveがあり、そのうちの１割強が特権昇格ができちゃう。やばい。
linuxは規模からいっても、そんなに「安全」なソフトウェアではない。
そういうカーネル。
歴史を振り返ると、よく使われている技術がサンドボックス可というものがある。

## About gVisor
この概念をコンテナにも導入できないか？といのがGviwor
ユーザーモードで動作する小さなカーネル。
カーネル内でシステムコールをトラップし実行する。
通常のプロセスのような柔軟なスレッド、メモリ割り当て
「仮想化と比べて」低いオーバーヘッド
干すカーネルから見れば、gvisoはたんなるps
通常のプロセスとおんなじ、柔軟性をそこなわない
gVisorについて。さらに。
信頼されないアプリケーションをサンドボックス可。Linuxのシステムコルをスクラッチで実装。やばそう
現在２１１のシステムコールを実装している
単なるフィルタリングではない
ユーザーもd−linuxのような移植版ではない
辺くを加えないlinuxバイナリを実行可能(NalCLとの違い）
また、最初からセキュアである。AppArmorやSELIぬんおポリシーと言ったフィルタが設定不要。さん土木巣ごとに１つのユーザーモードカーネルを実行できる。
メモリ及び方安全のために:gopher: で記述されている。
## gVisorのアーキテクチャについて
Sentryというプロセスと、Goferというプロセスが動いている。
Sentryはシステムコールをエミュレートする。Goferはファイルアクセスを専任に受け持つ。
IPC(9P)で通信する。
ネットワークはSentryないのユーザーモード、ネットワークスタックで処理

### Gofer - ファイルアクセスのための専用プロセス
なぜ分けるか？ふたつのpsに
最も頻繁にexploitされるsystemcallがsocket(2)とopen(2)
Sentryはこれらの呼び出しを許可されない。Sentryがもし乗っ取られたしてもファイルにアクセスしたりポートをひらくことができない。
システムコールをトラップするのはptrace。PTRACE＿SYSEMAMを使ってシステムコールをトラップする。すべてのLinux環境で動作するというメリットがある。互換性がたかい。
もうひとつはKVM(試験的）ｇVisorがVMM券げすとOSとして動作する。ハードウェアによる仮想化サポートが要件。
gVisorの性能について。メモリ使用量は15MB,起動時間は150ms。システムコールに若干のオーバヘッドというレベル。
コンテナはもっともとはやい、15msというはやさ。ただし仮想マシンよりもはやい。
gVisorが向いていない場面
異なる種類のゲストOSを動作させること。(linux上でうぃんどｗｓなど）
完全に信頼されたバイナリを実行する場合。
最適な性能を得るためには通常のコンテナを使う。
システムコールを多様するアプリケーションもむいてない
完全なアプリケーションｗの互換性を期待するのもターゲット外
Sentryは多くのシステムコールをサポートするが、全てではない。
それってLinuxの再実装じゃん？みたいなはなし
テスト済みアプリはいっぱい。go,nod,httpd,php,prometheus,java8,jenkins,python,mariadb,redis,registrymemcached,mongotomcat,wordpress,
かなりカバーしてるね。
gVisGAEはgVisorで動作している。短い起動速度と低いおバーヘッドが不可欠だから。
もうひとつ、OSカーネル自体の研究開発につかえるのではないかと期待されている。
gVisorをosカーネルの研究開発に利用できることがしてkしあれている。gvisorにごｄエヘンクオを加え、ユーザーモードで試験をする。Cでやるよりずっとはやーい！
理解した上で選択するのがもっともだいじ。gVisorは安全なサンドボックス内でコンテナを実行する新しい手法。裏方で動いている技術を理解することは、じぶんおアプリケーションのために最適なプラットフォームを選ぶ上で大事
gVisorを実行する方法はかんたん。dockerでやるときに--runtime=runscやるだけ
くばねのときは、crio.confに１行たすだけでいい。
単一コンテナのpodがサポート、複数こんてなのpodはちょい待って（実装中 
デモ。dockerで--runtime=runscをつけた場合、つけてない場合のやつ。runscつけるとgvisor上の実行になるため、メルトダウンがきかない。なしだとメルトダウン有効。あちゃー。
dockerで/proc/cpuinfo|lessはしらせてみ。そんだけでわかるから。
まとめ
サンドボクス内で安全にコンテナを実行する新しい手法
みじかいきどうじかん、柔軟なスレッドとメモリ割り当て、最小限のオーバーヘッド
メモリと方安全性のためにGoで記述されている
コンテナとホストOSの間に厳格な境界をもたらす
信頼されていないバイナリをコンテナ内でより安全に実行できる
裏方の技術をしることは正しい判断をする上で大切

休憩をはさんで次のプレゼンターは@apstndbさん
TITLE:gVisorとGCP

say3no [8:30 PM]
https://blog.jessfraz.com/post/containers-security-and-echo-chambers/
Jessie Frazelle's Blog
Jessie Frazelle's Blog: Containers, Security, and Echo Chambers
A rant on containers, security, and echo chambers.
gVisorがトレードオフとしたリソース効率の重要度はどれだけ高いのか？
googleは100%再生可能可能エネルギーで動かしてる。普通の企業だとなかなかできない。効率が悪いとユーザへのコストに添加されてしまう。電源設計レベルでも効率を追求。新規開発してでもサンドボックスもだきょうしないのは納得
36k google app engine RCE
se-2014-02 GAE java security sandbox bypasses
https://gist.github.com/apstndb
